# =============================================================================
# monday-access-service — Manual API Tests
# WebStorm REST Client (.http)
#
# HOW TO USE:
#   1. Start the server:  npm run dev
#   2. Run requests top-to-bottom (the Employee Login and Approver Login must
#      run first — they populate {{auth_token}} and {{admin_token}}).
#   3. After "Create Access Request", copy the returned `id` and paste it
#      into the @request_id variable below.
#
# MOCK USERS (seeded at startup):
#   alice@company.com  / Password123!  → EMPLOYEE
#   bob@company.com    / Password123!  → EMPLOYEE
#   carol@company.com  / Password123!  → APPROVER
#   dave@company.com   / Password123!  → APPROVER
# =============================================================================

@baseUrl   = http://localhost:3000

# After running "Create Access Request", paste the returned `id` here
# so the decide/fetch-by-id requests below can reuse it without copy-pasting.
@request_id =eb4dde67-37b0-4675-9ec3-46ae3ff6e049


# =============================================================================
# HEALTH CHECK
# =============================================================================

### Sanity-check that the server is up. No auth required.
# Expected: 200 { "status": "ok", "timestamp": "..." }
GET {{baseUrl}}/health


# =============================================================================
# EMPLOYEE WORKFLOW
# =============================================================================

### [1] Login as Employee (alice)
# Captures the JWT and stores it in the global variable {{auth_token}}.
# Run this before any other employee request.
# Expected: 200 { "data": { "token": "...", "user": { ... } } }
POST {{baseUrl}}/api/auth/login
Content-Type: application/json

{
  "email": "alice@company.com",
  "password": "Password123!"
}

> {%
  client.global.set("auth_token", response.body.data.token);
  client.log("Employee token captured: " + response.body.data.token.substring(0, 20) + "...");
%}

###

### [2] Create Access Request (Employee)
# Submits a new access request as alice. The request starts in PENDING status.
# Copy the `id` from the response and update @request_id at the top of this file.
# Expected: 201 { "data": { "id": "...", "status": "PENDING", "createdBy": "...", ... } }
POST {{baseUrl}}/api/access-requests
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "applicationName": "Salesforce CRM",
  "justification": "Need access to manage enterprise customer accounts for the Q3 sales cycle."
}

> {%
  client.global.set("request_id", response.body.data.id);
  client.log("Request ID captured: " + response.body.data.id);
%}

###

### [3] Get My Requests (Employee — own requests only)
# Retrieves all requests belonging to alice using her user ID from the token.
# Employees are restricted to their own requests by the service layer.
# Expected: 200 { "data": [ ... ] }
GET {{baseUrl}}/api/access-requests/user/user-alice-001
Authorization: Bearer {{auth_token}}

###

### [4] Get a Specific Request by ID (Employee — own request)
# Fetches the request created in step [2] using the captured @request_id.
# Expected: 200 { "data": { "id": "...", "status": "PENDING", ... } }
GET {{baseUrl}}/api/access-requests/{{request_id}}
Authorization: Bearer {{auth_token}}


# =============================================================================
# APPROVER (ADMIN) WORKFLOW
# =============================================================================

### [5] Login as Approver (carol)
# Captures the approver JWT and stores it in the global variable {{admin_token}}.
# Run this before any approver-only request.
# Expected: 200 { "data": { "token": "...", "user": { "role": "APPROVER", ... } } }
POST {{baseUrl}}/api/auth/login
Content-Type: application/json

{
  "email": "carol@company.com",
  "password": "Password123!"
}

> {%
  client.global.set("admin_token", response.body.data.token);
  client.log("Approver token captured: " + response.body.data.token.substring(0, 20) + "...");
%}

###

### [6] Get ALL Requests (Approver only)
# Lists every access request regardless of requester. EMPLOYEE role would get 403 here.
# Expected: 200 { "data": [ ... all requests ... ] }
GET {{baseUrl}}/api/access-requests
Authorization: Bearer {{admin_token}}

###

### [7] Filter Requests by Status — PENDING (Approver only)
# Useful for an approver dashboard that only shows items that need action.
# Expected: 200 { "data": [ ... only PENDING requests ... ] }
GET {{baseUrl}}/api/access-requests/status/PENDING
Authorization: Bearer {{admin_token}}

###

### [8] Filter Requests by Status — APPROVED (Approver only)
# Expected: 200 { "data": [ ... only APPROVED requests ... ] }
GET {{baseUrl}}/api/access-requests/status/APPROVED
Authorization: Bearer {{admin_token}}

###

### [9] Filter Requests by Status — DENIED (Approver only)
# Expected: 200 { "data": [ ... only DENIED requests ... ] }
GET {{baseUrl}}/api/access-requests/status/DENIED
Authorization: Bearer {{admin_token}}

###

### [10] Get Any User's Requests (Approver viewing alice's requests)
# Approvers can query by any userId. An employee doing the same for another
# user would receive 403 (see edge cases below).
# Expected: 200 { "data": [ ... alice's requests ... ] }
GET {{baseUrl}}/api/access-requests/user/user-alice-001
Authorization: Bearer {{admin_token}}

###

### [11] APPROVE a Request (Approver only)
# Transitions the request from PENDING → APPROVED.
# Make sure @request_id is set (from step [2] or a seeded ID).
# Expected: 200 { "data": { "status": "APPROVED", "decisionBy": "...", "decisionAt": "...", ... } }
PATCH {{baseUrl}}/api/access-requests/{{request_id}}/decision
Content-Type: application/json
Authorization: Bearer {{admin_token}}

{
  "decision": "APPROVED",
  "decisionNote": "Approved after verifying business justification and completing security review."
}

###

### [12] DENY a Request (Approver only)
# To test this, first create another request (re-run step [2]) and use its ID.
# Transitions the request from PENDING → DENIED.
# Expected: 200 { "data": { "status": "DENIED", "decisionBy": "...", "decisionAt": "...", ... } }
PATCH {{baseUrl}}/api/access-requests/{{request_id}}/decision
Content-Type: application/json
Authorization: Bearer {{admin_token}}

{
  "decision": "DENIED",
  "decisionNote": "Insufficient justification. Please provide a specific business case and re-submit."
}


# =============================================================================
# ERROR & EDGE CASES
# =============================================================================

### [E1] UNAUTHORIZED — No token provided
# Hitting a protected endpoint with no Authorization header.
# Expected: 401 { "error": { "message": "Missing or malformed Authorization header..." } }
POST {{baseUrl}}/api/access-requests
Content-Type: application/json

{
  "applicationName": "GitHub",
  "justification": "Need access to push code."
}

###

### [E2] UNAUTHORIZED — Invalid / malformed token
# A garbage token should be rejected by the JWT verification middleware.
# Expected: 401 { "error": { "message": "Invalid or expired token" } }
GET {{baseUrl}}/api/access-requests
Authorization: Bearer this.is.not.a.valid.token

###

### [E3] UNAUTHORIZED — Wrong password at login
# Both "wrong password" and "unknown email" return the same message
# to prevent user enumeration attacks.
# Expected: 401 { "error": { "message": "Invalid credentials" } }
POST {{baseUrl}}/api/auth/login
Content-Type: application/json

{
  "email": "alice@company.com",
  "password": "WrongPassword!"
}

###

### [E4] UNAUTHORIZED — Unknown email (same message as wrong password)
# Expected: 401 { "error": { "message": "Invalid credentials" } }
POST {{baseUrl}}/api/auth/login
Content-Type: application/json

{
  "email": "ghost@company.com",
  "password": "Password123!"
}

###

### [E5] FORBIDDEN — Employee attempts to approve a request (permission guard)
# The PATCH /decision endpoint requires the access_request:decide permission.
# An EMPLOYEE token hits the authorize middleware and is rejected before
# reaching the service layer.
# Expected: 403 { "error": { "message": "Access denied: role 'EMPLOYEE' does not have permission 'access_request:decide'" } }
PATCH {{baseUrl}}/api/access-requests/{{request_id}}/decision
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "decision": "APPROVED",
  "decisionNote": "I am approving my own request."
}

###

### [E6] FORBIDDEN — Employee attempts to list all requests
# GET /api/access-requests requires the access_request:view:all permission.
# Expected: 403 { "error": { "message": "Access denied: role 'EMPLOYEE' does not have permission 'access_request:view:all'" } }
GET {{baseUrl}}/api/access-requests
Authorization: Bearer {{auth_token}}

###

### [E7] FORBIDDEN — Employee attempts to view another user's requests
# Employees lack access_request:view:all, so the service rejects cross-user queries.
# Expected: 403 { "error": { "message": "You can only view your own access requests" } }
GET {{baseUrl}}/api/access-requests/user/user-bob-002
Authorization: Bearer {{auth_token}}

###

### [E8] VALIDATION ERROR — Invalid decision value
# The `decision` field only accepts "APPROVED" or "DENIED".
# Sending anything else fails Zod schema validation before the service is called.
# Expected: 400 { "error": { "message": "Validation failed", "details": [ ... ] } }
PATCH {{baseUrl}}/api/access-requests/{{request_id}}/decision
Content-Type: application/json
Authorization: Bearer {{admin_token}}

{
  "decision": "MAYBE"
}

###

### [E9] VALIDATION ERROR — Missing required field on create
# `justification` is required and must be at least 10 characters.
# Expected: 400 { "error": { "message": "Validation failed", "details": [ ... ] } }
POST {{baseUrl}}/api/access-requests
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "applicationName": "Slack"
}

###

### [E10] VALIDATION ERROR — Justification too short
# `justification` must be at least 10 characters.
# Expected: 400 { "error": { "message": "Validation failed", "details": [ ... ] } }
POST {{baseUrl}}/api/access-requests
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "applicationName": "Slack",
  "justification": "Need it."
}

###

### [E11] VALIDATION ERROR — Invalid status in path param
# The controller validates path param status before calling the service.
# Expected: 400 { "error": { "message": "Invalid status 'MAYBE'..." } }
GET {{baseUrl}}/api/access-requests/status/MAYBE
Authorization: Bearer {{admin_token}}

###

### [E12] NOT FOUND — Request ID does not exist
# Expected: 404 { "error": { "message": "Access request 'non-existent-id' not found" } }
PATCH {{baseUrl}}/api/access-requests/non-existent-id/decision
Content-Type: application/json
Authorization: Bearer {{admin_token}}

{
  "decision": "APPROVED"
}

###

### [E13] CONFLICT — Attempting to decide on an already-decided request
# Once a request is APPROVED or DENIED, it cannot be decided again.
# First approve the request (step [11]), then run this.
# Expected: 409 { "error": { "message": "Cannot decide on a request with status 'APPROVED'..." } }
PATCH {{baseUrl}}/api/access-requests/{{request_id}}/decision
Content-Type: application/json
Authorization: Bearer {{admin_token}}

{
  "decision": "DENIED",
  "decisionNote": "Trying to override a previous decision — should fail with 409."
}

###

### [E14] NOT FOUND — Unknown route
# Any path not registered by the app returns a structured 404.
# Expected: 404 { "error": { "message": "Route not found" } }
GET {{baseUrl}}/api/does-not-exist
Authorization: Bearer {{auth_token}}
